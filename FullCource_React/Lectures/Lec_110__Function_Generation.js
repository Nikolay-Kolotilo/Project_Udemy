'use strict';
/*Lec_110__Function_Generation. Это пробвинутый функционал JS
function*

Сводка
function* (ключевое слово function со звёздочкой) определяет функцию-генератор.

Синтаксис
function* name([param[, param[, ... param]]]) { statements }
name
    Имя функции.
param
    Именованные аргументы функции (параметры). Функция-генератор может иметь 255 аргументов.
statements
    Инструкции составляющие тело функции.
Описание
Генераторы являются функциями с возможностью выхода и последующего входа. 
Их контекст исполнения (значения переменных) сохраняется при последующих входах.
Когда вызывается функция-генератор, её тело исполняется не сразу; вместо этого возвращается объект-итератор. 
При вызове метода next() итератора тело функции-генератора исполняется до первого встреченного оператора yield, 
который определяет возвращаемое значение или делегирует дальнейшее выполнение другому генератору при помощи yield* 
anotherGenerator(). Метод next() возвращает объект со свойством value, содержащим отданное значение, 
и свойством done, которое указывает, что генератор уже отдал своё последнее значение. 
Вызов метода next() с аргументом прекращает выполнение функции-генератора, 
и заменяет инструкцию yield на которой было приостановлено выполнение на аргумент переданный в next().
0:15*/
function* generator() { // Выдают результат последовательно в зависимости от количества вызовов.
    yield 'S';  // За количество вызовов отвечает слово: yield
    yield 'c';
    yield 'r';
    yield 'i';
    yield 'p';
    yield 't';
}

const str = generator(); 

console.log(str.next());// Вызов следующего шага: Метод next(). 
console.log(str.next());
console.log(str.next()); //В консоли получаем:
/*
{ value: 'S', done: false } 1 поле: value со значением 'S'. 
                            2 поле: done, где сообщается выполнился ли наш генератор полностью - false.
{ value: 'c', done: false }
{ value: 'r', done: false }
При срабатывании ф-ия выдает объект где есть 2 поля.
*/
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next()); //При запуске в седьмой (последний) раз ф-ия выдает:
/*3:00
{ value: 'S', done: false }
{ value: 'c', done: false }
{ value: 'r', done: false }
{ value: 'i', done: false }
{ value: 'p', done: false }
{ value: 't', done: false }
{ value: undefined, done: true } после завершения функции такое сообщение теперь будем получать всегда.
*/
//3:40. Получение значения value:
console.log(str.next().value); //В консоли получаем undefined.
//4:00. Автоматическое формирование результата. Пример:

function* count(n) {
    for (let i = 0; i < n; i++) {
        yield i;
    }
};

//4:50 
const counter = count(7);
console.log(counter.next().value);
console.log(counter.next().value);
console.log(counter.next().value); //5:25 В консоли получаем:
/*
0
1
2
ф-ция работает так: цикл срабатывает столько раз сколько было обращений к ф-ции.
*/
//6:45. Цикл for of для function*
function* count(n) {
    for (let i = 0; i < n; i++) {
        yield i;
    }
};

for (let k of count(7)) {
    console.log(k);
}//5:25 В консоли получаем:
/*
0
1
2
3
4
5
6
цикл for используется для запуска максимального количества раз.
*/