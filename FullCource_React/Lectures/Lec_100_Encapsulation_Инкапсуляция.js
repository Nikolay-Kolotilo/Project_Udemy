'use strict';
/*
Lec_100_Encapsulation_Инкапсуляция. - Это отделение и сокрытие внутренностей программы
0:45. Для ООП - это означает, что объект хранит свои данные в приватном порядке и только его методы имеют доступ
к его данным.
1. Инкапсуляция
Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, 
манипулирующий зтими данными, а также защищает и то, 
и другое от внешнего вмешательства или неправильного использования. 
В объектно-ориентированном программировании код и данные могут быть объединены вместе; 
в этом случае говорят, что создаётся так называемый "чёрный ящик". 
Когда коды и данные объединяются таким способом, создаётся объект (object). 
Другими словами, объект - это то, что поддерживает инкапсуляцию.

Внутри объекта коды и данные могут быть закрытыми (private). 
Закрытые коды или данные доступны только для других частей этого объекта. 
Таким образом, закрытые коды и данные недоступны для тех частей программы, 
которые существуют вне объекта. Если коды и данные являются открытыми, то, 
несмотря на то, что они заданы внутри объекта, они доступны и для других частей программы. 
Характерной является ситуация, когда открытая часть объекта используется для того, 
чтобы обеспечить контролируемый интерфейс закрытых элементов объекта.

На самом деле объект является переменной определённого пользователем типа. 
Может показаться странным, что объект, который объединяет коды и данные, 
можно рассматривать как переменную. Однако применительно к объектно-ориентированному программированию 
это именно так. Каждый элемент данных такого типа является составной переменной.

2. Полиморфизм
Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, 
которое позволяет одно и то же имя использовать для решения двух или более схожих, 
но технически разных задач. Целью полиморфизма, 
применительно к объектно-ориентированному программированию, 
является использование одного имени для задания общих для класса действий. 
Выполнение каждого конкретного действия будет определяться типом данных. 
Например для языка Си, в котором полиморфизм поддерживается недостаточно, 
нахождение абсолютной величины числа требует трёх различных функций: abs(), labs() и fabs(). 
Эти функции подсчитывают и возвращают абсолютную величину целых, 
длинных целых и чисел с плавающей точкой соответственно. 
В С++ каждая из этих функций может быть названа abs(). 
Тип данных, который используется при вызове функции, определяет, 
какая конкретная версия функции действительно выполняется. 
В С++ можно использовать одно имя функции для множества различных действий. 
Это называется перегрузкой функций (function overloading).

В более общем смысле, концепцией полиморфизма является идея "один интерфейс, множество методов". 
Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. 
Преимуществом полиморфизма является то, что он помогает cнижать сложность программ, 
разрешая использование того же интерфейса для задания единого класса действий. 
Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор. 
Вам, как программисту, не нужно делать этот выбор самому. 
Нужно только помнить и использовать общий интерфейс. 
Пример из предыдущего абзаца показывает, как, имея три имени для функции 
определения абсолютной величины числа вместо одного, 
обычная задача становится более сложной, чем это действительно необходимо.

Полиморфизм может применяться также и к операторам. 
Фактически во всех языках программирования ограниченно применяется полиморфизм, 
например, в арифметических операторах. Так, в Си, символ + используется для складывания целых, 
длинных целых, символьных переменных и чисел с плавающей точкой. 
В этом случае компилятор автоматически определяет, какой тип арифметики требуется. 
В С++ вы можете применить эту концепцию и к другим, заданным вами, типам данных. 
Такой тип полиморфизма называется перегрузкой операторов (operator overloading).

Ключевым в понимании полиморфизма является то, что он позволяет вам манипулировать 
объектами различной степени сложности путём создания общего для них стандартного интерфейса 
для реализации похожих действий.

3. Наследовние
Наследование (inheritance) - это процесс, посредством которого один объект может приобретать 
свойства другого. Точнее, объект может наследовать основные свойства другого объекта 
и добавлять к ним черты, характерные только для него. 
Наследование является важным, поскольку оно позволяет поддерживать 
концепцию иерархии классов (hierarchical classification). 
Применение иерархии классов делает управляемыми большие потоки информации. 
Например, подумайте об описании жилого дома. Дом - это часть общего класса, называемого строением. 
С другой стороны, строение - это часть более общего класса - конструкции, 
который является частью ещё более общего класса объектов, 
который можно назвать созданием рук человека. В каждом случае порождённый класс наследует все, 
связанные с родителем, качества и добавляет к ним свои собственные определяющие характеристики. 
Без использования иерархии классов, для каждого объекта пришлось бы задать все характеристики, 
которые бы исчерпывающе его определяли. Однако при использовании наследования можно описать объект
путём определения того общего класса (или классов), к которому он относится, 
с теми специальными чертами, которые делают объект уникальным. 
Наследование играет очень важную роль в OOP. 

Приватные поля классов в процессе стандартизации JavaScript добрались до Stage 2. 
Это еще не финальная стадия, но комитет по стандартам JavaScript ожидает, 
что эта возможность будет разработана и в конечном итоге включена в стандарт 
(хотя она все еще может измениться).

Синтаксис (в настоящее время) выглядит так:
*/
class Point {
  #x;
  #y;  constructor(x, y) {
    this.#x = x;
    this.#y = y;
  }  equals(point) {
    return this.#x === point.#x && this.#y === point.#y;
  }
}
/*
В этом синтаксисе есть две важные части:

    Объявление приватных полей;
    Обращение к приватным полям.*/
//1:35. Инкапсуляция на примере Ф-ции конструктора.

function User(name, age) {
    this.name = name;
    this.age = age;

    this.say = function () { // 2:00 Создание метода объекта.
        console.log(`Имя пользователя: ${this.name}, возраст ${this.age}.`);
    };
}
//2:40. Использование функции this.say. С помощью конструктора

const ivan = new User('Ivan', 27);
//3:00. Получение доступа к свойствам
console.log(ivan.name); 
console.log(ivan.age); 
//3:25. Изменение свойства.
ivan.age = 30;
ivan.name = 'Alex';
ivan.say();// 3:45 Запускаем метод объекта.
/*
Получаем в консоли:
Ivan
27
Имя пользователя: Alex, возраст 30.
Это означает, что вносить изменения в данные объекта может любой.
4:10. Для избежания натой ситуации нам и нужна Инкапсуляция.
*/
function User(name, age) {
    this.name = name;
    let userAge = age;

    this.say = function () { // 2:00 Создание метода объекта.
        console.log(`Имя пользователя: ${this.name}, возраст ${userAge}.`);
    };
}
const ivan = new User('Ivan', 27);
console.log(ivan.name); 
console.log(ivan.userAge); 
ivan.userAge = 30;
ivan.name = 'Alex';
ivan.say();// 4:50 Запускаем метод объекта.
/*
Получаем в консоли:
Ivan
undefined
Имя пользователя: Alex, возраст 27.
Это означает, что переменная возраст существует только внутри объекта и не только получить ее не можем,
но и поменять также, потому как это не свойство объекта.

5:50. Создание внутри объекта 2-ух методов, которые будут работат с ЮзерЭйдж снаружи.
Будет по требованию отдавать значение и по требованию изменять.
Преимущество в том, что при изменении ЮзерЭйдж можно сделать проверку на правильность получения данных.
*/
//6:15
function User(name, age) {
    this.name = name;
    let userAge = age;

    this.say = function () { // 2:00 Создание метода объекта.
        console.log(`Имя пользователя: ${this.name}, возраст ${userAge}.`);
    };
    
    this.getAge = function () {
        return userAge;
    };

    this.setAge = function (age) {
        if (typeof age === 'number' && age > 0 && age < 110) {// 7:20 вариант проверки на число.
            userAge = age; 
        } else {
            console.log('Недопустимое значение'); //8:00.
        }
    };
}

const ivan = new User('Ivan', 27);
console.log(ivan.name); 
console.log(ivan.getAge()); 

ivan.setAge(30);
ivan.setAge(300);
console.log(ivan.getAge()); 

ivan.say();// 9:10 Запускаем метод объекта.
/*
Получаем в консоли:
Ivan - Значение из строки 183 (const ivan = new User('Ivan', 27);)
27 - Значение из строки 183 (const ivan = new User('Ivan', 27);)
Недопустимое значение - Значение из строки 188 (ivan.setAge(300));
30 - Значение из строки 189 (console.log(ivan.getAge())); 
Имя пользователя: Ivan, возраст 30. - Значение из строки 191 (ivan.say();)
*/
//10:15 Инкапсуляция на классах.

class User {
    constructor(name, age) {
        this.name = name;
        this.userAge = age;//let userAge = age; - userAge - должен быть свойством, а не переменной.
        //Теперь это свойство сделали публичным.
    }

    say() { // 2:00 Создание метода объекта.
        console.log(`Имя пользователя: ${this.name}, возраст ${userAge}.`);// userAge - должен быть свойством, а не переменной.
    }
    
    getAge() {
        return this.userAge;
    }

    setAge(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {// 7:20 вариант проверки на число.
            this.userAge = age; 
        } else {
            console.log('Недопустимое значение'); //8:00.
        }
    }
}

const ivan = new User('Ivan', 27);
console.log(ivan.name); 
console.log(ivan.getAge()); 

ivan.setAge(30);
ivan.setAge(300);
console.log(ivan.getAge()); 

ivan.say();// 12:50 Запускаем метод объекта. И получаем возможность редактировать св-ва объекта.
/*

*/
//13:00. Синтаксис для скрытия возможности редактирования _ - нижнее подчеркивание, просто договоренность среди
//программистов. Это не синтаксис языка.
class User {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }

    say() { 
        console.log(`Имя пользователя: ${this.name}, возраст ${this._age}.`);
    }
    
    get age() { //14:05
        return this._age;
    }

    set age(age) { //14:05
        if (typeof age === 'number' && age > 0 && age < 110) {// 7:20 вариант проверки на число.
            this._age = age; 
        } else {
            console.log('Недопустимое значение'); //8:00.
        }
    }
}

const ivan = new User('Ivan', 27);
console.log(ivan.age); 
ivan.age = 99;
console.log(ivan.age); 
ivan.say();// 14:50 Запускаем метод объекта. И получаем возможность редактировать св-ва объекта.
/*
27
99
Имя пользователя: Ivan, возраст 99.

Недостаток метода в том, что св-ва все равно можно менять.
*/
//16:25 Поля Класов - это экспериментальный синтаксис, не стандартизированный.
//Позволяет удобно записывать методы и св-ва классов.
class User {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }
        //17:00 Позволяет создавать св-ва класса вне конструктора
    surname = 'Petrichenko';

    say() { 
        console.log(`Имя пользователя: ${this.name} ${this.surname}/*17:20*/, возраст ${this._age}.`);
    }
    
    get age() { //14:05
        return this._age;
    }

    set age(age) { //14:05
        if (typeof age === 'number' && age > 0 && age < 110) {// 7:20 вариант проверки на число.
            this._age = age; 
        } else {
            console.log('Недопустимое значение'); //8:00.
        }
    }
}
const ivan = new User('Ivan', 27);
ivan.say();// 17:35 Запускаем метод объекта. 
/*
Имя пользователя: Ivan Petrichenko/*17:20, возраст 27.
18:05. Кроме этого методы в объекте мы можем задать в виде втрелочной функции.
В таком синтаксисе есть возможность задавать приватные св-ва класса, используя решетку: #
*/
class User {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }
        //17:00 Позволяет создавать св-ва класса вне конструктора
    #surname = 'Petrichenko';
    
    say = () => { 
        console.log(`Имя пользователя: ${this.name} ${this.#surname}/*17:20*/, возраст ${this._age}.`);
    }
    
    get age() { //14:05
        return this._age;
    }

    set age(age) { //14:05
        if (typeof age === 'number' && age > 0 && age < 110) {// 7:20 вариант проверки на число.
            this._age = age; 
        } else {
            console.log('Недопустимое значение'); //8:00.
        }
    }
}
const ivan = new User('Ivan', 27);
console.log(ivan.surname) //19:00. Обращение к свойству - без решетки #.
ivan.say();// 18:15 Запускаем метод объекта.
/* Получаем в консоли
undefined - св-во не доступно из-за решетки.
Имя пользователя: Ivan Petrichenko/*17:20/, возраст 27.
*/
//19:45. Домашнее задание. Создать Гетер и Сеттер для surname.
class User {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }
        //17:00 Позволяет создавать св-ва класса вне конструктора
    #surname = 'Petrichenko';
    
    say = () => { 
        console.log(`Имя пользователя: ${this.name} ${this.#surname}, возраст ${this._age}.`);
    }
    
    get age() { //14:05
        return this._age;
    }
    set age(age) { //14:05
        if (typeof age === 'number' && age > 0 && age < 110) {// 7:20 вариант проверки на число.
            this._age = age; 
        } else {
            console.log('Недопустимое значение'); //8:00.
        }
    }

    get surname() {//19:05
        return this.#surname;
    }
    set surname(surname) {  //14:05
        return this.#surname = surname;
    }
}
const ivan = new User('Ivan', 27);
console.log(ivan.surname)
ivan.surname = 'Nikolaevich'
console.log(ivan.surname)
ivan.say();


